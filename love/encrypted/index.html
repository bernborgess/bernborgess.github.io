<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d6d24b8faeb884ca4e8eeef6be7b1dbb0a4c7826e5e0c1a0948dc19cfbd5f044abda624b994d2999b20f80cbfd9974e390e350aeff6296d017add73b03e61bac1b9a7fcfc6fd7de5a26ba2af605c864aacae11fd18b8d66cc6c971e0fd80553cc94aeb9d69a084e553649f445b0b1197ab96875399d870fc13298c49115e69e8d9ecd49c47c86eff6f4dc70392aca919a3c211b95f8dda7a6ebce359d16e0096b4eb4ab21d4a3604744a22a6aedf4548f3f28e5dcda2ba3c0d3da824057ca5275cb85972932a67508b6ff6b86c74e10b2112b3b31afa51fa466b2dca1bb165361e3d56020bef8744664c31ff5fed33c75ed05b3acd4efae00d8a1373984533a472d98c08782c98cdfa199253dab7b6c02d2f3c9774739707e838ad34fd36f8b6792f066f71a63b7518e9cf349eeddd19de06d9261a3904fe6c5198fbd2e969978973320d6c3c3d3e1d539b5589ec98edda44eb99dd4afc7ac0e950a297a3bfa0cd0cc16a8f1da61a617fb0397e395281c5eb2440e557ff04bdf2b97d2e1ec48485c6d2e772338c689180fea6a63e367d27410c0b2f74e079ed301ec48b3219210822a9dad2a498f2237b39cdd56c3387702879be59069af85e321c99cd150643f749523200172b67e226d9e1e94508b36cd74e5aa8a452f76b689c1d50be71aa8b8d9fc6e62bcf63d90df92ebfd318d5b4f89a258efba30561bdaff131c0c08c098bf104fca9360851874e027278f7a1a6cceac0d6293d9ce38d9881b5f7717dfb450379f4668958c533a767cb18ba2eed358ed0fef65e5e144a6796751762a55402dfbf50d1604221e1b5bbec9b7232dae79e66c5d6447648c313a7eb67f1f143424871be64c69e8cab0e577157a5bebd5cd3e4b161d3cf9b4670be4ed9f34d6af480540d0adfb82f610983df1258c87fae4d65592123e22ab5a8b1c4d14ff46ce8317ead5f451bc19ba3f5d1b7b37c7561316f4809386c4aa110c478c1531192eaf9a9ae9574a401f218a038962c63efbecebf07047f7c83bd3bce7538df180d6055ec38478b46f18ee3364365795c4ab88842361a7d20be7b1750c94689804ea9d5263d641a12e5d6e13b4403bc0a065d01298f1cefce8433b9169cecdc2c3917d819154dbb4a58f3892ab53c8bed172d93bf5dabdba744596131c1a5fda543eecc926fdb08e43f7e5da8cb6ce866fea85e0823da6160c9fef8192ca7d159f590a77e85b02c3e5a6cc72db8c4b8feccf06a815ad5cef6b36bdb1653d770b5ec5f0b5642e9090df82c19708ddaa79b69136ad02f16f8d7095100d44e4b4f2ddc62b14102ea4bf1da031e41bfab2ca0c0e753b9bdf632efd9e5448c4494f8a2dcd54a849e6d0709162b0196fd7271d66186ca772ac8e06b36b137315e266b755b2a3d8ad39c0596528c2f9e2d46bceb4399e8c387ede1d1289e2f708d792377ff2d989c49fffac05952165cdc1e085bf42f63463bfb926b6f3a4afbe644238c70de907aad66620232074f413228919d27d8c37b01d279346e9802b028e02085dc56d395b47477f29812664ac5187d08541030d5aee8949e4a1ba1a41446614cf7c92fe7df904b42fe6bbcf1cea2c08ceffd4ac9d8fe860574781fb60d8db72e318f764d6ef4db75c6a14fa126f8c8d8108c1ec4179a0df528e0836d832f9dc2c687ec3362a59211db5ab9761591c199b09dfa9798e74a454c7c6df19d7a7c615d6f77e49956d2bea8bede01a2801310724f804482129622bbb9361543811cec021f3ba7d3fc17b836d2d3fbcf3eba373c95d747d343be0df2e7e43f6946bcb8c49985d30a17ea2c2649ce05673be9080ebef2828088f3e8a38e0db02bacee2179272583550faec69f90bc0a0520e87d1e511a3eea4f306805b4740bf687cbb8afabdded78e99d89622b34cc92dcdaa719b51e641426e31285385d4b13488d772d0bb43046afa9efba109fc791ad4117d2bb3d6ae652a96914c6cfa82f27b6e8205799c0995800d39be18e44dbc35bce6ac150ebf9491794739f7f715a252b75596bf25184bdbc774eded014347b0afb907d4f03e3b1c399ed06176c65e29f758629ce951a9587509d466a1864df87c0548350c2081ec8638f32e4c9b631c801363cf41ff851714ac7758e1c48c1addb462b49a0ee1da4621af5f75474da38e5a741f81f3f85388a87ae9d6bf7ce6f1ece8b628565fb913342dc51a41681a32c3dbf4f57e4a8bf50c78f4c6215b56bd7165e76e5f86d17c6df56e232a749375b2929a5041e8c13090deac74b7a2d24cdb731c2631bfca5089b7358418bac16765ff23ac45bbec9cda02d4d07e3de09b1800378ed0f3c8c1f575e11a3e297fdb234396dce091dedf11a6c36362304ffaad0e693b0aeb7ddc7d9ec27007c8d26378a76b97efe156b1b2c6f821253b6b4f45ddf039c77c65cca43a7382a091dd1ba886d3526240094d13085f9555c69965db3a140133798c9397fa9e1396fee47d9e6b1afb95668f57c9b6d694170cdae9fc96111be225daf3fb257590cc44d1ff0c3af03aa494425e98a14b3e49498d867f23b14a2e3e9261df76a46fc55548b4e2b5b1398ce2b8a79c544adc22040e067c7308e8476013928b72ecb2c94bb3cb39a8de3179f8608b04ac96cb53ff6c3623a3e0b8b47e58261758f8470cd9552dc8048a8b446dba066aa973c72080231494beebd08a775c9a8bf79717c58948c0b483f3190e0fd5b5e9c2c6838de56b90ce6cb0c6a67d7a447639ab51e7e710074840b829a31d3cbce032bc0107d39d27c281f22630e6fdb09758191f7b97bc1311691aad23be4d6c7e5652739741ab8639aa35b5a4ba2ad06de78118efc5c78af9af4189075c36886096c3c1c0aa7f51b49c871a72ab7fab794651be3c964f646cac6b47a774f17bce673267b2dd5e764757505ed47d8a4ef26eff12aedd5f8a856e2c03882ec5b50eb7119c97c57de6ab8b98aa8da2fb465c5d447592b99e171dd1ed5af266da6d683056d3130a625569a8d1ecc1a104f6b1c9d8e7c5dec18bcab8ec9f3900adf6a2c5f7ec73e12a41662b16b2ee6ab5e2036917f58f61cdc708970839cee7187ab6ccd0e6ee1e7b976e0bc7a5e86d84852deb5a89086a602b7bc87469271bb22e90f212c0ae18f97a4ace80aa53ea35df0e59397692f3b2cb47a170c840e53b6bd85a5d819f0f59bd2ff4192febdac1f2fb734cc9d94e11514bbb5ad2ac6be04cab91225d262205ac8482b55ceae30c4453d5df4bf34fdd8ce3ea5c0e3657a610945f49e87ea20335c969c2a31ec430a49a26d571daef2bcdcac9edaccd9dc617f0cf7c5789a09a3b72dfec8d8ec87a23f41097c17c57da68db56b7ab05a86a6ddf6996d94a275b9c871e73dbc7f1c959fd2e7054b8bec63b79008001a5687295e3781632064f315747ad4fe85662f80ce041c98e979570484252fc12b1633336fd918f22e2ce3df88077d22e162321af99fa38db5fb6aa8c9e3bd91472786945d5060829227f03d3b3eaffa6d9b790134f780ff97968f5f5f11321302fcac2db1488943cce371bf79992d9b78ffe6d3ebcba97b3a59dd773fe81f418141b9c1640deecbea3b9015549d1bab5f171d3cd30848f42477a66a881a197c0bd9181083c1e38426920e04ce36dc4530338ba7b9fa3d8215a72c01d4db02c71e8e18bf89f7b5966a3e466bb9ace100d7de688e17369678b2b85ce3e590421811c2bc2bce418a6c52897bb535e35f81d3c13172f981c1e6fd62e14ad25ed0b35d49f87a6306a0db2c950af77bee345f94d06fb636ffb40ac3fc59e7a7f57495b63fba6d1a0f33afbd84d904012d1defdd154e5865c8a586d8382cc48e2fb4af85c6f96533f7f589ed5b71e92b4243e9a8352adf1b4c838434148414d50d1bb6470a65faf07308d77deec8c97b673809d388ed4ed2c7706aaa3959cdaa3f28c7ee704879023feb075bdc07a85df529da40e91f889da4371605b896770684185f5ec4d6a4fc06abf18fdb407c69e3789c17ac649a95869b26738e5706c976ea588f3d06f3dad755f12fe1245f12fabc181aeb4c606954bb8a355e87329418bd96ed8c6eaad20263b820e13a77727f5c675f584f0e246771842c279eff110f1183883bfdb69a9f6c68cea4982d696522999a581466f0bb6823700bef8436ef19e2a1e1750ef4545bfe7b23a55bbd1cbdcb5efa9d63f60cd5a2db4ff365814fbc89e1797e26fde585b5bc4d5c58682cc7ea08d88b0834dbd1c8313e3ade032540ad79807d17d37a987d40c5bda8362a0dd33e02b549ca417718074a753a836581821f895fb31c1734225f51931f4ebb7dd7bfec8b21bfacfe6270f4c9c8ed3a8051af96aabfb27c5a1ad4d69ec1df0721dd8fee2c48f71f95dfc1f98d7e344553d9864dafc224bd3307c94235b5cdea811dbc83bd453d0ad8dc6b127c60f3fc6c8384f74d404fc0e9be7954e93fb1e68ada24c1d103e69ed05c996334e541d43aefd755b8081ca8e5b5eeb41276a8d97bc58c40dd09c7c23ac82dc70cbbc608a54a751968208aabc79a2babefd3bd1c4c4320aeab050a04209ae117911976a47c7b0140cbb49e2aa0523904d1ffb8cb51de56766ee45f5736ff0642f787ab928e4f8d270d43448e5bd8fba1f3dc1cd0c6b6a6079d7f607c0a84dfdf3b9ba08e72735f4be95b5da35d953700d6b00d7e9a8325ee1e96aa6ed9a7ee8101e05ff057c7fa3db97def6b3fbbf8b70f397b047e9e80644c3fe4dcf6cc1b8e8b11cc3b27625035276925cfb8978b6ddb811f32322abce37f0b51d8a7cefc214fb3645a8481736107c447f31e8e3e72afba249250f0b82092e0c6afdaf76974b79b7939a91bd385e326c7348636d0ca38aa554424f3894273c74560a7707eba68d5fc0b8887f00484b382746a3bd0225481aa52b86c26a90e8adc57c9f04ac9cc2c0ba75eed0c78fe7f98fb5b8849fa0a7f466790526b8d78beb520be2694a1af1bbe6506de041517e9d60ff729beb49990f7954fa8282a0c703146262dd52b2b06b639340c4661329a5b2efe44bfd0fb7e62d0a85d107ec409c6388cbf5ac1c79c56571e1caaecf91e0060bbc319c688d795f8230954e7d2748c41ea6adda2d1934b55d05971f537b6ccdc8d76501f1088166f740c04dfa670f4dcb90585978ae5c9d50273ea213ed1ad37b6ac0e3473f092040498411ef2595954a09689117167f22242cade899e8cebab326447e5bf691733716db1c8e45b58343d55904fcf290670d0107772e286026f7c77e08c915e5cadf098e1243b000530fb08906f738bbb5da67749d7f74391a3d44c46fe155dd3e21dda6cc940974f35ff71aa346bb99cc46ade8a97383d122f56c9779f236f596dbbe91266f61e320a9eeb7755f09453cf3860e8e8f99ca0da5c33dac0d8aea9bdff0d5200fc84121583d2222d85070475bca033373f8355a94b7fca25fcbefaf20993d23f743428676ac7b1d83b86b7800ffadafbd517ef7e3633504c80a74d605e2e3c5e95dd826618c4a83d9a1d7f916b65b721bd722ad4d9be665c4b005200cfdcfb313913af1c1156eb06e3ba51eee93379975ce0ae6e9a89691e4d4f640eb500bc0870a166baaa32b3e7e4d13ac2f6271cae7f92baa591a4a19ed5b916f501e6207e219917c5970dda7774e2f2c9969f2df804ba6022fee45cb183752d0d69ecc6a781ccd3740f656d52d8095358e3e6e59d1b64499d82d5520a0f83d986290ba8b731f2e64aed3562e2ca7a4b99d6be6441f034f19b4e939d1a78752bc27b0a838833419ae153e71ed4b75a6fdd34f596ba1f8343144bde8d2bfa66744b266d2ce617142e72c8827be5425299be5d31052468bae37f952f94950659988165c4ae2e209166311514933544a6e7ece7352de55ebb8a7834207a9c96b17932b7c841369c24f73f8197be1ecadeb4b8b3005a8754ef6da9830505b76b80de1499f6bb32b6a07405c8578e9df9a546babe84f1726a4c665c8ed9c1a1294b5306cd5323dede0927d44e4e5e7de8a685e5408dcfd298f6149e8bf7d3ebfaa904a4ce471d4d40a58f34a1c1c2196052f9de02a585ad794356f82b8d7039be8fe4a628101d020ca65c1c6ea2a2d46700e92df454e9398dabd2593eaa9678e9e98bffe8151b2d84dda25f950c1b4d53ba770cca3c55d89d8c8925e1b7165dabebae47259bb37a1e10ec3cbae3e5d91a632a6ad813f1a1ee200c5248fa902f3ecf730d5c69b798f57b50167dd244325edd4bcc5b287e8d3e5d59549a9549ea29e9652f1a0c64c2cc031b5a220e3e9b09c15172fbff7eea7f6b31b71b0ecb24b930e27702acef7cfee33baea85f5ee891fc97a31fe8d81cc19b4c1183856b38e38eb45b9c937bdb429bf7047537a3da8bec65b5a0c9a7825b24e2e4ee0457f8ce7a26c0eaac9847bc990ecf79c119561ef0b88f5f57cae97112315b115e319debc6fdf292030104e7cc7a394e7292b63830fc791a89fe2488dff33c93874426d29e7d42de85e3c6a1caf350162f12aa39a0b55fbff81a02a374988c569949c70998f3bce4c323e21e05e1788d5839d933193db1c50811f42473d3c0020a0ebe6808feadb2b91d421ec97b132a29a356d15ee79d2e4c58740b22dc30c42b403d4ce8c3bb1970884a2972e94d1f6f8ddc9e64cf112fb027e2c4467a0eacbadcb8009d37aced1f6a2f4b2c6c453391ec51d61dd601a91834a18d45a94df47bacdcd91d640dec87bd79f3e9773fc30caf861f12212cc94abbbfa1b99e8ad7b4c4bc9590517b11a143e12f8b1d0f586822b92d36c659be089fe3d52371679fcdc97b5b33b6eb5921d3bb72ba0893f98a29146a78656d7839216e6586c2802f81d495034cb230b59282cb7e94f4e11e87807261c23b8fa9faf97e5048d009db4cad5c2ab7ab08dc132426239b4bc71c20d86c2100fb86e64ca64de891eb6bad013411ac77dd4f89ec17eed124397c3bc16eab833dedccb3437b6df8de839966d1e083884a23436f969add222fedc2a8effc7b8b1a581de4d4f108dc428b16e5879c5fc3c710f52980fe09ec03038bd6d9631f9ab2c4401bf888cf840ab5a49ae8cb5f404e89c77f0a1cb3e0a1d87c4758c92e75eff035b7e3b9cd1ae5212d7769f98d9b7df0d2519bceb338d54115e2e9fa309931a48c0de4da29ceea275f48edc4718a8018caa86fac3bf81846bd4b834ff1078a5a08bd13ea8cc60148f1c8d52c66d7cde8f750a58e2b8790e71c630884a0fa99e7759d3454208a3c4e362f4faaedaa9c244b9252e28bc952e3e1a4c959c578d0b71481f7d320ce69c13a894e297bd5afac0b127421e06c35051e7fc53e1e76dc7064e1eb76a12662621e35b88c2dafdbf06428eac070ec2f68f1e3644a5c9a2dacb11896527d75a902b45b743adf50dcbb57d494ff770d8224387c996c154e708d3772a8f19a2ea8c1507fdb710a7b5d6ecccd9e65c59437483fb6b1f5ce92a975e164b3ccd19a2a4ef693fccc8ecc6e37e75924b0b19daeafb907c58d4d8816e7e50a86ac39dcba62e466867fe14a8bf0f4c15c132347406e20a4931461a188f7127accb1dc245fe3e1911650138b17faf34a490befea4da95cdc62ce9a42464f2d239aef2a0c1e3b6b6cbbf960da6157c76b025083175bec800d96cf9081970af19490454ce7909f8f0c801d33a7da4e74d6db99995cab3025713ad2a01462239cdaff5693adebb58d1d9de30afe32f1fb2e073f6a1b7357250935251b9dc91d26fa245d8be8888148ff917feba1996b3e3a2111a2e6064e3f5f1638030fee8a68d24e0db2aab88f19511c24f9cdfac024d125c525bb0ca5b7c081624fc8a2d23ed0c67ee03f7a1ff9b7753c73edfd037406f7af604442afc9eb6bd2ac0025df8315c7fec24431d2ac600287b0dc63f478e6c25acb212689b2987658dec23765cf7f65130bf8b3d8f4402d1bb84197180bc2d60d960a8486c6e51c85823e51c12b366339b352161013db98dbedbf6be54b75098e3c6b52abbb232a7716ed1cc83d4360797c9b25a634d744bbdab8fdd6057c61a46cf36f9d114506f3a46f25ffea1599e93903ebc53f430b57c0675573b7150b54dc3fe0319a4b8ebc7754bf83d3fc79e25aaa3367fbf45c4a5b8bdf2d4809030973a7770f01433b45ec76621f790613aeb2eeb583c4d2b9429623794f25467caf4b2299b130eb19306158f4897c79d815ee77d3021019922a6878cbe1c3c3fd37561b8b22fcf11dbe54152883dc997772b37b44a0116ae7616793ccb27b6251f05b77aa25e57786bdccf87e93b6046255b23e711d996f58eda3ce46adbdc7f8791bbb227b41b05ab43a2c8dedb62a1477568c292afc4dcc5d5bf4c2c67da2a26a626fa79576bb7f959306921c4fd47fe2bc1622dbd6b4fb57308545a9cf4b3150e5331a4c484dbb490ae65405dc561c28491c53fca075bb3958fab04596919bfbf699024634a9ebcb6e4c76d27853957ae59581fea12962ba63307a16c20fdc4599c7c550c410aa81bf765ebfa171c1cc82c060cf01d17403d59e60fc9815bf9fba8c5227b14846f2e78212200ed564e806aaaa44771ce65a2dc35fe037882bd72d61388cb3e648bc268718fe7dc40e7889169577c9166c52dd479ce2c359d22d8d998287eb8e4eaae6376f56fc60414a819af4d07a13b7bd2773350612f936f16256ba8a4c4cd6a7d42b7b3eba053d26f94714a87a4ff60b913ea2913785e9f3a1a0a3b7f3e82bccc47dd5a8448eec03d1b7230e1e463cff86379e5ad6e5fc261836e7dff2aa669ab134ee7f84d183cdfe8389fb157fba285c12f7874bc7bc781214e9a361f39628e4fc0d9d8c1862fadce2039d81caca6bb331d9f4c51e43837d33e45590100f8a8c81876d9358054495b673021024f6bd74d648fbdb26a7cadf4e411b8c7e7f12e7aa534b6c3035c79939bcfd7b0e71f1b2f8a91bafbe7a41eb53dc0641049187be0ac28a88488e9631755bbf52a16669be1933b908bc77dd3307c5ee1837ada654534c94f9225e1fd1febc864e55fd93de936f3f1b01ff8d0ef07727edf5a9043ef0ca9b9252bbd7942fdf7c7d4333a10b04ddf1d926147af774f49595429a1e84041a3a7d77f7cfee9e5084d618b7a9d5d62d79713088e12f44b4193653e617adb7706bb2b80c2e31eceb544314c9750714ca2da7fbc5b9ccfb521ef004ff9e54d73d8cd9ceed54eed8b61a32082ed56393210bc94c0d0b7f814f4e9e652b21893a70f443d0d9a44d81e79c76d4c56b0f93aaf00c4f53ac1c5aca2fa878e91254125c74d27c790da6e9b4f46924bbca41cbfd1a4fd77c5a83c8cb38bcdb522b00286ade71427ba939068d7471fcd3be4607e2a312ac8bdb54007ccdc2d81b6300ad7803fa696ef5bf4d5ced3f3aa06422c6a4e834a8b094663d8271039e889280afd8f745e75516d81a8c4f464359b13860641cd38f98d0c643f4900feca93fe27833c4aafaeb0e35d3b9a3d0f517f6764c1fee4c07ede333e17d07fb99d2a6d02d919e3e8cfabc09e09519bc54870deecd2c3f45f0b4d7b51735192f5f626e5c9a20548708419c01c0b1369b94a57d3f7f18e251496a91999d92a1d4f1ceed85cb85baecbe051be1a308f2df2771199c5fbffd6b97bf181186ac5d4efb629f920e4922f7bed7fef1ca587605e1bb80ffaec9b958ff9f402f30a5611c46faa215bcb1b0300f13c78b8d35f2cbfc278869d285946044c9acdcd0b1cfacd99fd900f764397362359afc8dc7da6a59aafcde0f5ca9e28d4ad378ebc63e2848d24792bbc134a3f976722177016510912aa3eb2659c23ad5eb812ff45787d2dd7930e8b1d5ec1b3c4c86b65227c43c24a524640088d9c12fdf0712688eacdae3809e3d39365a128e5ed0b64596ca3ba42be224e9e762ad38fc1ee00aa2dd9e674093fdc7be45bbabfc2e4a6e3cf038d297704e6646aadd24e92fde9806d4546f829c0a610b6debd119f93819c9504b722da09b2c255bdb0372e49810962cea5fa2f3da1134c96f7ba7fa268b21d42efd243736d330dc658a2a00a780c0e263f322ba649e44cc4c6d6d79b5f482dab2e566157e0a6294d1e6eab2a38b34dcec18a60e75108afdf2ef7f553ea5de818fb1a04bb182ed52d41231ef84c7cac45c778613590dc453fe5798ae274c8021ed2d267da72320f2823329fb1414eab9c029d95eee123567d9774ca2d93e0bc6ad4f281961ddd2b70958408721c657258dfcc80e3224d7f713b0c24e4d2c45830d1efab3524d600f8ce3d01113335c5cba3ac28e938bf56f6ae90b0c1333622282e220863404678c4591fe95e8a2f95a3be53ea0997383aaf7ab9877898aa1c5800ee05830b8b1a88c7f9307f898806df2d4efe85ce70cb665e8a146bd46f931365f26793b008b44b3a2c4db2e8e5d7d4e89a432c152f3df6f5d6a47ce3e9757f56d16cfbb8d57b821316e78be6c395ed36bde73f74421dd74be425faf4ffeb864e5560cc2c4babd90af1ab3dca5615c73ebf5b6dffbe648cbee4796c4097b65cde57c0486155f5d9de4cd34ce30a8895cb134409cd0b641dfd7e3e6ffab0bf9003e66bfc9efd203021fb695b27a7ea3c69eac1db4590b1639821b0cf8c935402b6959f677fab479933c7fd0a225aa3a3781897de8f124bf8eacd501152412211d60bb43be063d78ac15444989e485463172d3a76afb827b3a1d0fe4c737e839b19b1000a68caf7953b7539bf1e87db78dbe1a2786653f0aaa0e41a62cbbc4150ffe708deb9f7deee8d3761f152189fbd768ea0cea6d530fbe089100cea8d0dcc8dfc4928cc4197e2d02f0ee6ff754084ded278d5765866f503c64ac898e639ae00136ca8dcaec047e98c01442c84a49889268225b84e742006f8400099508fa4f6c683279392b03448a1b2ac4487e6ad2aa66c21a11a82534273bbd0935b04e7a398222489310ea72b66449916aa0d6afc1e2c645f5e3c2076239608f0d5cce9e45631a99942ccc839df26578acb60033357a57097ec0e0949edbb576de1354a12a4ee0a8ec87553a824786d86b4392595585519820ea589c9ccf36490f51faa30b3de92002c22aba08f84afc4cea2c674b2bbbadb75601244660bbdd8273d29fc25079e85457f01e2154d09f5722bf2322354d7ae86f875cc737adb38f826afa4bd601119dcca51d4beb279c69d3b7855d31f39ec0b4387db10cbb80eb347105afd50d721ea2f7548f4c330687df48bf5cd04cb19c4f816ba99fb140829878e4b6c96974648c0e8c0d59300ebd0b552e03d29455c6c81","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"640907808d59d7ca9fcd4f6c6c0c124c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
